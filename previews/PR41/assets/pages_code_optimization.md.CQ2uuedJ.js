import{_ as n,C as l,c as p,o as r,j as t,aA as a,a as e,G as o}from"./chunks/framework.Dl-SWwoj.js";const j=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/code/optimization.md","filePath":"pages/code/optimization.md","lastUpdated":null}'),d={name:"pages/code/optimization.md"},c={class:"jldocstring custom-block",open:""},h={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""};function A(C,i,S,T,z,F){const s=l("Badge");return r(),p("div",null,[t("details",c,[t("summary",null,[i[0]||(i[0]=t("a",{id:"Sindbad.ParameterOptimization",href:"#Sindbad.ParameterOptimization"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization")],-1)),i[1]||(i[1]=e()),o(s,{type:"info",class:"jlObjectType jlModule",text:"Module"})]),i[2]||(i[2]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ParameterOptimization</span></span></code></pre></div><p>The <code>ParameterOptimization</code> module provides tools for optimizing SINDBAD models, including parameter estimation, model calibration, and cost function evaluation. It integrates various optimization algorithms and utilities to streamline the optimization workflow for SINDBAD experiments.</p><p><strong>Purpose:</strong></p><p>This module is designed to support optimization tasks in SINDBAD, such as calibrating model parameters to match observations or minimizing cost functions. It leverages multiple optimization libraries and provides a unified interface for running optimization routines.</p><p><strong>Dependencies:</strong></p><ul><li><p><code>CMAEvolutionStrategy</code>: Covariance Matrix Adaptation Evolution Strategy backend.</p></li><li><p><code>Evolutionary</code>: Additional evolutionary/metaheuristic optimizers.</p></li><li><p><code>ForwardDiff</code>: Automatic differentiation for gradient-based workflows.</p></li><li><p><code>MultistartOptimization</code>: Multi-start orchestration utilities.</p></li><li><p><code>NLopt</code>: Large suite of derivative-free and gradient-based optimizers.</p></li><li><p><code>Optim</code>: Quasi-Newton and trust-region algorithms (BFGS, LBFGS, etc.).</p></li><li><p><code>Optimization</code> + <code>OptimizationOptimJL</code>: SciML interface plus the Optim bridge.</p></li><li><p><code>OptimizationGCMAES</code> / <code>OptimizationCMAEvolutionStrategy</code>: Extra CMA-ES variants exposed through <code>Optimization</code>.</p></li><li><p><code>QuasiMonteCarlo</code>: Low-discrepancy sequence sampling (initial populations, Sobol sets, etc.).</p></li><li><p><code>StableRNGs</code>: Reproducible random number generation for stochastic optimizers.</p></li><li><p><code>GlobalSensitivity</code>: Sobol/variance-based sensitivity tooling for pre/post analysis.</p></li><li><p><code>SindbadTEM</code> and <code>SindbadTEM.Utils</code>: Core TEM types and helper utilities.</p></li><li><p><code>SindbadTEM.Metrics</code>: Metric/cost definitions referenced during optimization.</p></li><li><p><code>Sindbad.Setup</code> / <code>Sindbad.Simulation</code>: Provide the experiment <code>info</code> and runtime hooks the optimizers call.</p></li></ul><p><strong>Included Files:</strong></p><ol><li><strong><code>optimizer.jl</code></strong>:</li></ol><ul><li>Implements the core optimization logic, including merging algorithm options and selecting optimization methods.</li></ul><ol start="2"><li><strong><code>cost.jl</code></strong>:</li></ol><ul><li>Defines cost functions for evaluating the loss of SINDBAD models against observations.</li></ul><ol start="3"><li><strong><code>optimizeTEM.jl</code></strong>:</li></ol><ul><li><p>Provides functions for optimizing SINDBAD TEM parameters for single locations or small spatial grids.</p></li><li><p>Functionality to handle optimization using large-scale 3D data YAXArrays cubes, enabling parameter calibration across spatial dimensions.</p></li></ul><ol start="4"><li><strong><code>sensitivityAnalysis.jl</code></strong>:</li></ol><ul><li>Provides functions for performing sensitivity analysis on SINDBAD models, including global sensitivity analysis and local sensitivity analysis.</li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><ul><li><p>The package integrates multiple optimization libraries, allowing users to choose the most suitable algorithm for their problem.</p></li><li><p>Designed to be modular and extensible, enabling users to customize optimization workflows for specific use cases.</p></li><li><p>Supports both gradient-based and derivative-free optimization methods, ensuring flexibility for different types of cost functions.</p></li></ul></div><p><strong>Examples:</strong></p><ol><li><strong>Running an experiment</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Sindbad</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Simulation</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Set up experiment parameters</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">experiment_config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Run the experiment</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">runExperimentOpti</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(experiment_config)</span></span></code></pre></div><ol><li><strong>Running a CMA-ES optimization</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Sindbad</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ParameterOptimization</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">optimized_params </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> optimizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cost_function, default_values, lower_bounds, upper_bounds, algo_options, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CMAEvolutionStrategyCMAES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div>`,21))]),i[36]||(i[36]=t("h2",{id:"Exported",tabindex:"-1"},[e("Exported "),t("a",{class:"header-anchor",href:"#Exported","aria-label":'Permalink to "Exported {#Exported}"'},"​")],-1)),t("details",h,[t("summary",null,[i[3]||(i[3]=t("a",{id:"Sindbad.ParameterOptimization.cost",href:"#Sindbad.ParameterOptimization.cost"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.cost")],-1)),i[4]||(i[4]=e()),o(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[5]||(i[5]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_vector, default_values, selected_models, space_forcing, space_spinup_forcing, loc_forcing_t, output_array, space_output, space_land, tem_info, observations, parameter_updater, cost_options, multi_constraint_method, parameter_scaling_type, cost_method</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CostMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculate the cost for a parameter vector.</p><p><strong>Arguments</strong></p><ul><li><p><code>parameter_vector</code>: Vector of parameter values to be optimized</p></li><li><p>&#39;default_values&#39;: Default values for model parameters</p></li><li><p><code>selected_models</code>: Collection of selected models for simulation</p></li><li><p><code>space_forcing</code>: Forcing data for the main simulation period</p></li><li><p><code>space_spinup_forcing</code>: Forcing data for the spin-up period</p></li><li><p><code>loc_forcing_t</code>: Time-specific forcing data</p></li><li><p><code>output_array</code>: Array to store simulation outputs</p></li><li><p><code>space_output</code>: Spatial output configuration</p></li><li><p><code>space_land</code>: Land surface characteristics</p></li><li><p><code>tem_info</code>: Temporal information for simulation</p></li><li><p><code>observations</code>: Observed data for comparison</p></li><li><p><code>parameter_updater</code>: Function to update parameters</p></li><li><p><code>cost_options</code>: Options for cost function calculation</p></li><li><p><code>multi_constraint_method</code>: Method for handling multiple constraints</p></li><li><p><code>parameter_scaling_type</code>: Type of parameter scaling</p></li><li><p><code>sindbad_cost_method &lt;: CostMethod</code>: a type parameter indicating cost calculation method</p></li></ul><p><strong>Returns</strong></p><p>Cost value representing the difference between model outputs and observations</p><p><strong>sindbad_cost_method:</strong></p><p><strong>CostMethod</strong></p><p>Abstract type for cost calculation methods in SINDBAD</p><p><strong>Available methods/subtypes:</strong></p><ul><li><p><code>CostModelObs</code>: cost calculation between model output and observations</p></li><li><p><code>CostModelObsLandTS</code>: cost calculation between land model output and time series observations</p></li><li><p><code>CostModelObsMT</code>: multi-threaded cost calculation between model output and observations</p></li><li><p><code>CostModelObsPriors</code>: cost calculation between model output, observations, and priors. NOTE THAT THIS METHOD IS JUST A PLACEHOLDER AND DOES NOT CALCULATE PRIOR COST PROPERLY YET</p></li></ul>',11))]),t("details",u,[t("summary",null,[i[6]||(i[6]=t("a",{id:"Sindbad.ParameterOptimization.costLand",href:"#Sindbad.ParameterOptimization.costLand"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.costLand")],-1)),i[7]||(i[7]=e()),o(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[8]||(i[8]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">costLand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_vector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, selected_models, forcing, spinup_forcing, loc_forcing_t, land_timeseries, land_init, tem_info, observations, parameter_updater, cost_options, multi_constraint_method, parameter_scaling_type)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">costLand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_vector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, selected_models, forcing, spinup_forcing, loc_forcing_t, _, land_init, tem_info, observations, parameter_updater, cost_options, multi_constraint_method, parameter_scaling_type)</span></span></code></pre></div><p>Calculates the cost of SINDBAD model simulations for a single location by comparing model outputs as collections of SINDBAD <code>land</code> with observations using specified metrics and constraints.</p><p>In the first variant, the <code>land_time_series</code> is preallocated for computational efficiency. In the second variant, the runTEM stacks the land using map function and the preallocations is not necessary.</p><p><strong>Arguments:</strong></p><ul><li><p><code>parameter_vector::AbstractArray</code>: A vector of model parameter values to be optimized.</p></li><li><p><code>selected_models</code>: A tuple of selected SINDBAD models in the given model structure, the parameters of which are optimized.</p></li><li><p><code>forcing</code>: A forcing NamedTuple containing the time series of environmental drivers for the simulation.</p></li><li><p><code>spinup_forcing</code>: A forcing NamedTuple for the spinup phase, used to initialize the model to a steady state.</p></li><li><p><code>loc_forcing_t</code>: A forcing NamedTuple for a single location and a single time step.</p></li><li><p><code>land_timeseries</code>: A preallocated vector to store the land state for each time step during the simulation.</p></li><li><p><code>land_init</code>: The initial SINDBAD land NamedTuple containing all fields and subfields.</p></li><li><p><code>tem_info</code>: A nested NamedTuple containing necessary information for running SINDBAD TEM, including helpers, models, and spinup configurations.</p></li><li><p><code>observations</code>: A NamedTuple or vector of arrays containing observational data, uncertainties, and masks for calculating performance metrics.</p></li><li><p><code>parameter_updater</code>: A function to update model parameters based on the <code>parameter_vector</code>.</p></li><li><p><code>cost_options</code>: A table specifying how each observation constraint should be used to calculate the cost or performance metric.</p></li><li><p><code>multi_constraint_method</code>: A method for combining the vector of costs into a single cost value or vector, as required by the optimization algorithm.</p></li><li><p><code>parameter_scaling_type</code>: Specifies the type of scaling applied to the parameters during optimization.</p></li></ul><p><strong>Returns:</strong></p><ul><li><code>cost_metric</code>: A scalar or vector representing the cost, calculated by comparing model outputs with observations using the specified metrics and constraints.</li></ul><div class="tip custom-block"><p class="custom-block-title">Note</p><ul><li><p>The function updates the selected models using the <code>parameter_vector</code> and <code>parameter_updater</code>.</p></li><li><p>It runs the SINDBAD TEM simulation for the specified location using <code>runTEM</code>.</p></li><li><p>The model outputs are compared with observations using <code>metricVector</code>, which calculates the performance metrics.</p></li><li><p>The resulting cost vector is combined into a single cost value or vector using <code>combineMetric</code> and the specified <code>multi_constraint_method</code>.</p></li></ul></div><p><strong>Examples:</strong></p><ol><li><strong>Calculating cost for a single location</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> costLand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_vector, selected_models, forcing, spinup_forcing, loc_forcing_t, land_timeseries, land_init, tem_info, observations, parameter_updater, cost_options, multi_constraint_method, parameter_scaling_type)</span></span></code></pre></div><ol><li><strong>Using a custom multi-constraint method</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">custom_method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CustomConstraintMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> costLand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_vector, selected_models, forcing, spinup_forcing, loc_forcing_t, land_timeseries, land_init, tem_info, observations, parameter_updater, cost_options, custom_method, parameter_scaling_type)</span></span></code></pre></div><ol><li><strong>Handling observational uncertainties</strong>:</li></ol><ul><li>Observations can include uncertainties and masks to refine the cost calculation, ensuring robust model evaluation.</li></ul>`,15))]),t("details",m,[t("summary",null,[i[9]||(i[9]=t("a",{id:"Sindbad.ParameterOptimization.getCostVectorSize",href:"#Sindbad.ParameterOptimization.getCostVectorSize"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.getCostVectorSize")],-1)),i[10]||(i[10]=e()),o(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[11]||(i[11]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getCostVectorSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(algo_options, parameter_vector, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ParameterOptimizationMethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GSAMethod)</span></span></code></pre></div><p>Calculates the size of the cost vector required for a specific optimization or sensitivity analysis method.</p><p><strong>Arguments:</strong></p><ul><li><p><code>algo_options</code>: A NamedTuple or dictionary containing algorithm-specific options (e.g., population size, number of trajectories).</p></li><li><p><code>parameter_vector</code>: A vector of parameters used in the optimization or sensitivity analysis.</p></li><li><p><code>::ParameterOptimizationMethod</code>: The optimization or sensitivity analysis method. Supported methods include:</p><ul><li><p><code>CMAEvolutionStrategyCMAES</code>: Covariance Matrix Adaptation Evolution Strategy.</p></li><li><p><code>GSAMorris</code>: Morris method for global sensitivity analysis.</p></li><li><p><code>GSASobol</code>: Sobol method for global sensitivity analysis.</p></li><li><p><code>GSASobolDM</code>: Sobol method with Design Matrices.</p></li></ul></li></ul><p><strong>Returns:</strong></p><ul><li>An integer representing the size of the cost vector required for the specified method.</li></ul><p><strong>Notes:</strong></p><ul><li><p>For <code>CMAEvolutionStrategyCMAES</code>, the size is determined by the population size or a default formula based on the parameter vector length.</p></li><li><p>For <code>GSAMorris</code>, the size is calculated as the product of the number of trajectories and the length of the design matrix.</p></li><li><p>For <code>GSASobol</code>, the size is determined by the number of parameters and the number of samples.</p></li><li><p>For <code>GSASobolDM</code>, the size is equivalent to that of <code>GSASobol</code>.</p></li></ul>',8))]),t("details",g,[t("summary",null,[i[12]||(i[12]=t("a",{id:"Sindbad.ParameterOptimization.globalSensitivity",href:"#Sindbad.ParameterOptimization.globalSensitivity"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.globalSensitivity")],-1)),i[13]||(i[13]=e()),o(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[14]||(i[14]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">globalSensitivity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cost_function, method_options, p_bounds, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GSAMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; batch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Performs global sensitivity analysis using the specified method.</p><p><strong>Arguments:</strong></p><ul><li><p><code>cost_function</code>: A function that computes the cost or output of the model based on input parameters.</p></li><li><p><code>method_options</code>: A set of options specific to the chosen sensitivity analysis method.</p></li><li><p><code>p_bounds</code>: A vector or matrix specifying the bounds of the parameters for sensitivity analysis.</p></li><li><p><code>::GSAMethod</code>: The sensitivity analysis method to use.</p></li><li><p><code>batch</code>: A boolean flag indicating whether to perform batch processing (default: <code>true</code>).</p></li></ul><p><strong>Returns:</strong></p><ul><li>A <code>results</code> object containing the sensitivity indices and other relevant outputs for the specified method.</li></ul><p><strong>algorithm:</strong></p><p><strong>GSAMethod</strong></p><p>Abstract type for global sensitivity analysis methods in SINDBAD</p><p><strong>Available methods/subtypes:</strong></p><ul><li><p><code>GSAMorris</code>: Morris method for global sensitivity analysis</p></li><li><p><code>GSASobol</code>: Sobol method for global sensitivity analysis</p></li><li><p><code>GSASobolDM</code>: Sobol method with derivative-based measures for global sensitivity analysis</p></li></ul><hr><p><strong>Extended help</strong></p><p><strong>Notes:</strong></p><ul><li><p>The function internally calls the <code>gsa</code> function from the GlobalSensitivity.jl package with the specified method and options.</p></li><li><p>The <code>cost_function</code> should be defined to compute the model output based on the input parameters.</p></li><li><p>The <code>method_options</code> argument allows fine-tuning of the sensitivity analysis process for each method.</p></li></ul>',15))]),t("details",k,[t("summary",null,[i[15]||(i[15]=t("a",{id:"Sindbad.ParameterOptimization.optimizeTEM",href:"#Sindbad.ParameterOptimization.optimizeTEM"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.optimizeTEM")],-1)),i[16]||(i[16]=e()),o(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[17]||(i[17]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">optimizeTEM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(forcing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, observations, info</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Arguments:</strong></p><ul><li><p><code>forcing</code>: a forcing NT that contains the forcing time series set for ALL locations</p></li><li><p><code>observations</code>: a NT or a vector of arrays of observations, their uncertainties, and mask to use for calculation of performance metric/loss</p></li><li><p><code>info</code>: a SINDBAD NT that includes all information needed for setup and execution of an experiment</p></li></ul>',3))]),t("details",b,[t("summary",null,[i[18]||(i[18]=t("a",{id:"Sindbad.ParameterOptimization.optimizeTEMYax-NTuple{5, NamedTuple}",href:"#Sindbad.ParameterOptimization.optimizeTEMYax-NTuple{5, NamedTuple}"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.optimizeTEMYax")],-1)),i[19]||(i[19]=e()),o(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[20]||(i[20]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">optimizeTEMYax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(forcing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, output</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, optim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, observations</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; max_cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Optimizes the Terrestrial Ecosystem Model (TEM) parameters for each pixel by mapping over the YAXcube(s).</p><p><strong>Arguments</strong></p><ul><li><p><code>forcing::NamedTuple</code>: Input forcing data for the TEM model</p></li><li><p><code>output::NamedTuple</code>: Output configuration settings</p></li><li><p><code>tem::NamedTuple</code>: TEM model parameters and settings</p></li><li><p><code>optim::NamedTuple</code>: Optimization parameters and settings</p></li><li><p><code>observations::NamedTuple</code>: Observed data for model calibration</p></li></ul><p><strong>Keywords</strong></p><ul><li><code>max_cache::Float64=1e9</code>: Maximum cache size for optimization process</li></ul><p><strong>Returns</strong></p><p>Optimized TEM parameters cube</p>',8))]),t("details",f,[t("summary",null,[i[21]||(i[21]=t("a",{id:"Sindbad.ParameterOptimization.optimizer",href:"#Sindbad.ParameterOptimization.optimizer"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.optimizer")],-1)),i[22]||(i[22]=e()),o(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[23]||(i[23]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">optimizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cost_function, default_values, lower_bounds, upper_bounds, algo_options, algorithm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ParameterOptimizationMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Optimize model parameters using various optimization algorithms.</p><p><strong>Arguments:</strong></p><ul><li><p><code>cost_function</code>: A function handle that takes a parameter vector as input and calculates a cost/loss (scalar or vector).</p></li><li><p><code>default_values</code>: A vector of default parameter values to initialize the optimization.</p></li><li><p><code>lower_bounds</code>: A vector of lower bounds for the parameters.</p></li><li><p><code>upper_bounds</code>: A vector of upper bounds for the parameters.</p></li><li><p><code>algo_options</code>: A set of options specific to the chosen optimization algorithm.</p></li><li><p><code>algorithm</code>: The optimization algorithm to be used.</p></li></ul><p><strong>Returns:</strong></p><ul><li><code>optim_para</code>: A vector of optimized parameter values.</li></ul><p><strong>algorithm:</strong></p><p><strong>ParameterOptimizationMethod</strong></p><p>Abstract type for optimization methods in SINDBAD</p><p><strong>Available methods/subtypes:</strong></p><ul><li><p><code>BayesOptKMaternARD5</code>: Bayesian Optimization using Matern 5/2 kernel with Automatic Relevance Determination from BayesOpt.jl</p></li><li><p><code>CMAEvolutionStrategyCMAES</code>: Covariance Matrix Adaptation Evolution Strategy (CMA-ES) from CMAEvolutionStrategy.jl</p></li><li><p><code>EvolutionaryCMAES</code>: Evolutionary version of CMA-ES optimization from Evolutionary.jl</p></li><li><p><code>OptimBFGS</code>: Broyden-Fletcher-Goldfarb-Shanno (BFGS) from Optim.jl</p></li><li><p><code>OptimLBFGS</code>: Limited-memory Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) from Optim.jl</p></li><li><p><code>OptimizationBBOadaptive</code>: Black Box Optimization with adaptive parameters from Optimization.jl</p></li><li><p><code>OptimizationBBOxnes</code>: Black Box Optimization using Natural Evolution Strategy (xNES) from Optimization.jl</p></li><li><p><code>OptimizationBFGS</code>: BFGS optimization with box constraints from Optimization.jl</p></li><li><p><code>OptimizationFminboxGradientDescent</code>: Gradient descent optimization with box constraints from Optimization.jl</p></li><li><p><code>OptimizationFminboxGradientDescentFD</code>: Gradient descent optimization with box constraints using forward differentiation from Optimization.jl</p></li><li><p><code>OptimizationGCMAESDef</code>: Global CMA-ES optimization with default settings from Optimization.jl</p></li><li><p><code>OptimizationGCMAESFD</code>: Global CMA-ES optimization using forward differentiation from Optimization.jl</p></li><li><p><code>OptimizationMultistartOptimization</code>: Multi-start optimization to find global optimum from Optimization.jl</p></li><li><p><code>OptimizationNelderMead</code>: Nelder-Mead simplex optimization method from Optimization.jl</p></li><li><p><code>OptimizationQuadDirect</code>: Quadratic Direct optimization method from Optimization.jl</p></li></ul><hr><p><strong>Extended help</strong></p><p><strong>Notes:</strong></p><ul><li><p>The function supports a wide range of optimization algorithms, each tailored for specific use cases.</p></li><li><p>Some methods do not require bounds for optimization, while others do.</p></li><li><p>The <code>cost_function</code> should be defined by the user to calculate the loss based on the model output and observations. It is defined in cost.jl.</p></li><li><p>The <code>algo_options</code> argument allows fine-tuning of the optimization process for each algorithm.</p></li><li><p>Some algorithms (e.g., <code>BayesOptKMaternARD5</code>, <code>OptimizationBBOxnes</code>) require additional configuration steps, such as setting kernels or merging default and user-defined options.</p></li></ul><p><strong>Examples:</strong></p><ol><li><strong>Using CMAES from CMAEvolutionStrategy.jl</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">optim_para </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> optimizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cost_function, default_values, lower_bounds, upper_bounds, algo_options, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CMAEvolutionStrategyCMAES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><ol><li><strong>Using BFGS from Optim.jl</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">optim_para </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> optimizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cost_function, default_values, lower_bounds, upper_bounds, algo_options, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OptimBFGS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><ol><li><strong>Using Black Box Optimization (xNES) from Optimization.jl</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">optim_para </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> optimizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cost_function, default_values, lower_bounds, upper_bounds, algo_options, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OptimizationBBOxnes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p><strong>Implementation Details:</strong></p><ul><li><p>The function internally calls the appropriate optimization library and algorithm based on the <code>algorithm</code> argument.</p></li><li><p>Each algorithm has its own implementation details, such as handling bounds, configuring options, and solving the optimization problem.</p></li><li><p>The results are processed to extract the optimized parameter vector (<code>optim_para</code>), which is returned to the user.</p></li></ul>',24))]),t("details",y,[t("summary",null,[i[24]||(i[24]=t("a",{id:"Sindbad.ParameterOptimization.prepOpti",href:"#Sindbad.ParameterOptimization.prepOpti"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.prepOpti")],-1)),i[25]||(i[25]=e()),o(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[26]||(i[26]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prepOpti</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(forcing, observations, info, cost_method</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CostModelObs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Prepares optimization parameters, settings, and helper functions based on the provided inputs.</p><p><strong>Arguments:</strong></p><ul><li><p><code>forcing</code>: Input forcing data used for the optimization process.</p></li><li><p><code>observations</code>: Observed data used for comparison or calibration during optimization.</p></li><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of the experiment.</p></li><li><p><code>cost_method</code>: The method used to calculate the cost function.</p></li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple <code>opti_helpers</code> containing: <ul><li><p><code>parameter_table</code>: Processed model parameters for optimization.</p></li><li><p><code>cost_function</code>: A function to compute the cost for optimization.</p></li><li><p><code>cost_options</code>: Options and settings for the cost function.</p></li><li><p><code>default_values</code>: Default parameter values for the models.</p></li><li><p><code>lower_bounds</code>: Lower bounds for the parameters.</p></li><li><p><code>upper_bounds</code>: Upper bounds for the parameters.</p></li><li><p><code>run_helpers</code>: Helper information for running the optimization.</p></li></ul></li></ul><p><strong>cost_method:</strong></p><p><strong>CostMethod</strong></p><p>Abstract type for cost calculation methods in SINDBAD</p><p><strong>Available methods/subtypes:</strong></p><ul><li><p><code>CostModelObs</code>: cost calculation between model output and observations</p></li><li><p><code>CostModelObsLandTS</code>: cost calculation between land model output and time series observations</p></li><li><p><code>CostModelObsMT</code>: multi-threaded cost calculation between model output and observations</p></li><li><p><code>CostModelObsPriors</code>: cost calculation between model output, observations, and priors. NOTE THAT THIS METHOD IS JUST A PLACEHOLDER AND DOES NOT CALCULATE PRIOR COST PROPERLY YET</p></li></ul><hr><p><strong>Extended help</strong></p><p><strong>Notes:</strong></p><ul><li><p>The function processes the input data and configuration to set up the optimization problem.</p></li><li><p>It prepares model parameters, cost options, and helper functions required for the optimization process.</p></li><li><p>Depending on the <code>cost_method</code>, the cost function is customized to handle specific data types or computation methods.</p></li></ul>',15))]),t("details",E,[t("summary",null,[i[27]||(i[27]=t("a",{id:"Sindbad.ParameterOptimization.prepParameters-Tuple{Any, Any}",href:"#Sindbad.ParameterOptimization.prepParameters-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.prepParameters")],-1)),i[28]||(i[28]=e()),o(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[29]||(i[29]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prepParameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_table, parameter_scaling)</span></span></code></pre></div><p>Prepare model parameters for optimization by processing default and bounds of the parameters to be optimized.</p><p><strong>Arguments</strong></p><ul><li><p><code>parameter_table</code>: Table of the parameters to be optimized</p></li><li><p><code>parameter_scaling</code>: Scaling method/type for parameter optimization</p></li></ul><p><strong>Returns</strong></p><p>A tuple containing processed parameters ready for optimization</p>',6))]),i[37]||(i[37]=t("h2",{id:"Internal",tabindex:"-1"},[e("Internal "),t("a",{class:"header-anchor",href:"#Internal","aria-label":'Permalink to "Internal {#Internal}"'},"​")],-1)),t("details",_,[t("summary",null,[i[30]||(i[30]=t("a",{id:"Sindbad.ParameterOptimization.optimizeYax-Tuple",href:"#Sindbad.ParameterOptimization.optimizeYax-Tuple"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.optimizeYax")],-1)),i[31]||(i[31]=e()),o(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[32]||(i[32]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">optimizeYax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(map_cubes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; out</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, optim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, forcing_vars</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, obs_vars</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A helper function to optimize parameters for each pixel by mapping over the YAXcube(s).</p><p><strong>Arguments</strong></p><ul><li><p><code>map_cubes...</code>: Variadic input of cube maps to be optimized</p></li><li><p><code>out::NamedTuple</code>: Output configuration parameters</p></li><li><p><code>tem::NamedTuple</code>: TEM (Terrestrial Ecosystem Model) configuration parameters</p></li><li><p><code>optim::NamedTuple</code>: Optimization configuration parameters</p></li><li><p><code>forcing_vars::AbstractArray</code>: Array of forcing variables used in optimization</p></li><li><p><code>obs_vars::AbstractArray</code>: Array of observation variables used in optimization</p></li></ul>',4))]),t("details",v,[t("summary",null,[i[33]||(i[33]=t("a",{id:"Sindbad.ParameterOptimization.unpackYaxOpti-Tuple{Any}",href:"#Sindbad.ParameterOptimization.unpackYaxOpti-Tuple{Any}"},[t("span",{class:"jlbinding"},"Sindbad.ParameterOptimization.unpackYaxOpti")],-1)),i[34]||(i[34]=e()),o(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[35]||(i[35]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unpackYaxOpti</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args; forcing_vars</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Unpacks the variables for the mapCube function</p><p><strong>Arguments</strong></p><ul><li><p><code>all_cubes</code>: Collection of cubes containing input, output and optimization/observation variables</p></li><li><p><code>forcing_vars::AbstractArray</code>: Array specifying which variables should be forced/constrained</p></li></ul><p><strong>Returns</strong></p><p>Unpacked data arrays</p>',6))])])}const D=n(d,[["render",A]]);export{j as __pageData,D as default};
