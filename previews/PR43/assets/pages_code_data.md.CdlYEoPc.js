import{_ as l,C as o,c as d,o as p,j as e,aA as t,a,G as n}from"./chunks/framework.DSiJSBhI.js";const z=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/code/data.md","filePath":"pages/code/data.md","lastUpdated":null}'),r={name:"pages/code/data.md"},c={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},h={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""};function R(O,i,w,M,Y,q){const s=o("Badge");return p(),d("div",null,[e("details",c,[e("summary",null,[i[0]||(i[0]=e("a",{id:"Sindbad.DataLoaders",href:"#Sindbad.DataLoaders"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders")],-1)),i[1]||(i[1]=a()),n(s,{type:"info",class:"jlObjectType jlModule",text:"Module"})]),i[2]||(i[2]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DataLoaders</span></span></code></pre></div><p>The <code>DataLoaders</code> module provides tools for ingesting and preprocessing SINDBAD input data. It supports reading, cleaning, masking, and managing forcing/observation data with an emphasis on spatial and temporal dimensions.</p><p><strong>Purpose</strong></p><p>Streamline the ingestion and preprocessing of input data for SINDBAD experiments.</p><p><strong>Dependencies</strong></p><p><strong>Related (SINDBAD ecosystem)</strong></p><ul><li><code>UtilsKit</code>: Utility functions for handling NamedTuples, printing, and shared helpers.</li></ul><p><strong>External (third-party)</strong></p><ul><li><p><code>AxisKeys</code>: Labeled multidimensional arrays (<code>KeyedArray</code>).</p></li><li><p><code>DimensionalData</code>: Dimension-aware indexing/slicing.</p></li><li><p><code>FillArrays</code>: Efficient filled-array representations.</p></li><li><p><code>NCDatasets</code>: NetCDF reader/writer.</p></li><li><p><code>YAXArrays</code>, <code>YAXArrayBase</code>: Multidimensional array/cube abstractions used for IO and spatial data.</p></li><li><p><code>Zarr</code>: Chunked/compressed array storage for large datasets.</p></li></ul><p><strong>Internal (within <code>Sindbad</code>)</strong></p><ul><li><p><code>Sindbad.Setup</code></p></li><li><p><code>Sindbad.Types</code></p></li><li><p><code>SindbadTEM</code></p></li></ul><p><strong>Included Files</strong></p><ul><li><p><strong><code>utilsDataLoaders.jl</code></strong>: Utility functions for data preprocessing (cleaning, masking, bounds checks).</p></li><li><p><strong><code>spatialSubset.jl</code></strong>: Spatial operations (extracting subsets based on spatial dimensions).</p></li><li><p><strong><code>getForcing.jl</code></strong>: Extracting and processing forcing data (environmental drivers).</p></li><li><p><strong><code>getObservation.jl</code></strong>: Reading and processing observational data for evaluation/validation.</p></li></ul><p><strong>Notes</strong></p><ul><li><p>The module uses <code>NCDatasets</code>, <code>YAXArrays</code>, and <code>Zarr</code> directly; it does not re-export them.</p></li><li><p>Designed to handle large datasets efficiently, leveraging chunked and compressed data formats like NetCDF and Zarr.</p></li><li><p>Ensures compatibility with SINDBAD&#39;s experimental framework by integrating spatial and temporal data management tools.</p></li></ul>',15))]),i[78]||(i[78]=e("h2",{id:"Exported",tabindex:"-1"},[a("Exported "),e("a",{class:"header-anchor",href:"#Exported","aria-label":'Permalink to "Exported {#Exported}"'},"​")],-1)),e("details",u,[e("summary",null,[i[3]||(i[3]=e("a",{id:"Sindbad.DataLoaders.AllNaN",href:"#Sindbad.DataLoaders.AllNaN"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.AllNaN")],-1)),i[4]||(i[4]=a()),n(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[5]||(i[5]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AllNaN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> YAXArrays.DAT.ProcFilter</span></span></code></pre></div><p>Specialized filter for YAXArrays to skip pixels with all <code>NaN</code> or <code>missing</code> values.</p><p><strong>Description</strong></p><p>This struct is used as a specialized filter in data processing pipelines to identify or handle cases where all values in a data segment are NaN (Not a Number).</p>',4))]),e("details",h,[e("summary",null,[i[6]||(i[6]=e("a",{id:"Sindbad.DataLoaders.getForcing-Tuple{NamedTuple}",href:"#Sindbad.DataLoaders.getForcing-Tuple{NamedTuple}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getForcing")],-1)),i[7]||(i[7]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[8]||(i[8]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getForcing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(info</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Reads forcing data from the <code>data_path</code> specified in the experiment configuration and returns a NamedTuple with the forcing data.</p><p><strong>Arguments:</strong></p><ul><li><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple <code>forcing</code> containing: <ul><li><p><code>data</code>: The processed input cubes.</p></li><li><p><code>dims</code>: The dimensions of the forcing data.</p></li><li><p><code>variables</code>: The names of the forcing variables.</p></li><li><p><code>f_types</code>: The types of the forcing data (e.g., <code>ForcingWithTime</code> or <code>ForcingWithoutTime</code>).</p></li><li><p><code>helpers</code>: Helper information for the forcing data.</p></li></ul></li></ul><p><strong>Notes:</strong></p><ul><li><p>Reads forcing data from the specified data path and processes it using the SINDBAD framework.</p></li><li><p>Handles spatiotemporal and spatial-only forcing data.</p></li><li><p>Applies masks and subsets to the forcing data if specified in the configuration.</p></li></ul>',8))]),e("details",g,[e("summary",null,[i[9]||(i[9]=e("a",{id:"Sindbad.DataLoaders.getNumberOfTimeSteps-Tuple{Any, Any}",href:"#Sindbad.DataLoaders.getNumberOfTimeSteps-Tuple{Any, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getNumberOfTimeSteps")],-1)),i[10]||(i[10]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[11]||(i[11]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getNumberOfTimeSteps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(incubes, time_name)</span></span></code></pre></div><p>Returns the number of time steps in the input data cubes.</p><p><strong>Arguments</strong></p><ul><li><p><code>incubes</code>: Input data cubes containing temporal information</p></li><li><p><code>time_name</code>: Name of the time dimension/variable</p></li></ul><p><strong>Returns</strong></p><p>Integer representing the total number of time steps in the data</p>',6))]),e("details",k,[e("summary",null,[i[12]||(i[12]=e("a",{id:"Sindbad.DataLoaders.getObservation-Tuple{NamedTuple, NamedTuple}",href:"#Sindbad.DataLoaders.getObservation-Tuple{NamedTuple, NamedTuple}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getObservation")],-1)),i[13]||(i[13]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[14]||(i[14]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getObservation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(info</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, forcing_helpers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Processes observation data and returns a NamedTuple containing the observation data, dimensions, and variables.</p><p><strong>Arguments:</strong></p><ul><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</p></li><li><p><code>forcing_helpers</code>: A SINDBAD NamedTuple containing helper information for forcing data.</p></li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple with the following fields: <ul><li><p><code>data</code>: The processed observation data as an input array.</p></li><li><p><code>dims</code>: The dimensions of the observation data.</p></li><li><p><code>variables</code>: A tuple of variable names for the observation data.</p></li></ul></li></ul><p><strong>Notes:</strong></p><ul><li><p>Reads observation data from the path specified in the experiment configuration.</p></li><li><p>Handles quality flags, uncertainty, spatial weights, and selection masks for each observation variable.</p></li><li><p>Subsets and harmonizes the observation data based on the target dimensions and masks.</p></li></ul>',8))]),e("details",y,[e("summary",null,[i[15]||(i[15]=e("a",{id:"Sindbad.DataLoaders.getSpatialSubset-Tuple{Any, Any}",href:"#Sindbad.DataLoaders.getSpatialSubset-Tuple{Any, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getSpatialSubset")],-1)),i[16]||(i[16]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[17]||(i[17]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getSpatialSubset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ss, v)</span></span></code></pre></div><p>Extracts a spatial subset of data based on specified spatial subsetting type/strategy.</p><p><strong>Arguments</strong></p><ul><li><p><code>ss</code>: Spatial subset parameters or geometry defining the region of interest</p></li><li><p><code>v</code>: Data to be spatially subset</p></li></ul><p><strong>Returns</strong></p><p>Spatially subset data according to the specified parameters</p><p><strong>Note</strong></p><p>The function assumes input data and spatial parameters are in compatible formats</p>',8))]),e("details",b,[e("summary",null,[i[18]||(i[18]=e("a",{id:"Sindbad.DataLoaders.mapCleanData-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, Val{T}}} where T",href:"#Sindbad.DataLoaders.mapCleanData-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, Val{T}}} where T"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.mapCleanData")],-1)),i[19]||(i[19]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[20]||(i[20]=t("<p>Maps and cleans data based on quality control parameters and fills missing values.</p><p><strong>Arguments</strong></p><ul><li><p><code>_data</code>: Raw input data to be cleaned</p></li><li><p><code>_data_qc</code>: Quality control data corresponding to input data</p></li><li><p><code>_data_fill</code>: Fill values for replacing invalid/missing data</p></li><li><p><code>bounds_qc</code>: Quality control bounds/thresholds</p></li><li><p><code>_data_info</code>: Additional information about the data</p></li><li><p><code>::Val{T}</code>: Value type parameter for dispatch</p></li></ul><p><strong>Returns</strong></p><p>Cleaned and mapped data with invalid values replaced according to QC criteria</p><p><strong>Note</strong></p><p>This function performs quality control checks and data cleaning based on the provided bounds and fill values. The exact behavior depends on the value type T.</p>",7))]),e("details",m,[e("summary",null,[i[21]||(i[21]=e("a",{id:"Sindbad.DataLoaders.subsetAndProcessYax-Union{Tuple{num_type}, Tuple{Any, Any, Any, Any, Any, Val{num_type}}} where num_type",href:"#Sindbad.DataLoaders.subsetAndProcessYax-Union{Tuple{num_type}, Tuple{Any, Any, Any, Any, Any, Val{num_type}}} where num_type"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.subsetAndProcessYax")],-1)),i[22]||(i[22]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[23]||(i[23]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">subsetAndProcessYax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(yax, forcing_mask, tar_dims, _data_info, info, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{num_type}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; clean_data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, fill_nan</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, yax_qc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, bounds_qc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {num_type}</span></span></code></pre></div><p>Subset and process YAX data according to specified parameters and quality control criteria.</p><p><strong>Arguments</strong></p><ul><li><p><code>yax</code>: YAX data to be processed</p></li><li><p><code>forcing_mask</code>: Mask to apply to the data</p></li><li><p><code>tar_dims</code>: Target dimensions</p></li><li><p><code>_data_info</code>: Data information</p></li><li><p><code>info</code>: a SINDBAD NT that includes all information needed for setup and execution of an experiment</p></li><li><p><code>::Val{num_type}</code>: Value type parameter for numerical type specification</p></li><li><p><code>clean_data=true</code>: Boolean flag to enable/disable data cleaning</p></li><li><p><code>fill_nan=false</code>: Boolean flag to control NaN filling</p></li><li><p><code>yax_qc=nothing</code>: Optional quality control parameters for YAX data</p></li><li><p><code>bounds_qc=nothing</code>: Optional boundary quality control parameters</p></li></ul><p><strong>Returns</strong></p><p>Processed and subset YAX data according to specified parameters and quality controls.</p><p><strong>Type Parameters</strong></p><ul><li><code>num_type</code>: Numerical type specification for the processed data</li></ul>',8))]),e("details",f,[e("summary",null,[i[24]||(i[24]=e("a",{id:"Sindbad.DataLoaders.toDimStackArray-Tuple{Any, Any, Any}",href:"#Sindbad.DataLoaders.toDimStackArray-Tuple{Any, Any, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.toDimStackArray")],-1)),i[25]||(i[25]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[26]||(i[26]=t("<p>Convert a stacked array into a DimensionalArray with specified dimensions and metadata.</p><p><strong>Arguments</strong></p><ul><li><p><code>stackArr</code>: The input stacked array to be converted</p></li><li><p><code>time_interval</code>: Time interval information for temporal dimension</p></li><li><p><code>p_names</code>: Names of pools/variables</p></li><li><p><code>name</code>: Optional keyword argument to specify the name of the dimension (default: :pools)</p></li></ul><p><strong>Returns</strong></p><p>A DimensionalArray with proper dimensions and labels.</p><p>This function is useful for converting raw stacked arrays into properly dimensioned arrays with metadata, particularly for time series data with multiple pools or variables.</p>",6))]),e("details",T,[e("summary",null,[i[27]||(i[27]=e("a",{id:"Sindbad.DataLoaders.yaxCubeToKeyedArray-Tuple{Any}",href:"#Sindbad.DataLoaders.yaxCubeToKeyedArray-Tuple{Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.yaxCubeToKeyedArray")],-1)),i[28]||(i[28]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[29]||(i[29]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">yaxCubeToKeyedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c)</span></span></code></pre></div><p>Convert a YAXArray cube to a KeyedArray.</p><p><strong>Arguments</strong></p><ul><li><code>c</code>: YAXArray input cube to be converted</li></ul><p><strong>Returns</strong></p><p>KeyedArray representation of the input YAXArray cube</p><p><strong>Description</strong></p><p>Transforms a YAXArray data cube into a KeyedArray format, preserving the dimensional structure and associated metadata of the original cube.</p>',8))]),i[79]||(i[79]=e("h2",{id:"Internal",tabindex:"-1"},[a("Internal "),e("a",{class:"header-anchor",href:"#Internal","aria-label":'Permalink to "Internal {#Internal}"'},"​")],-1)),e("details",_,[e("summary",null,[i[30]||(i[30]=e("a",{id:"Sindbad.DataLoaders.applyQCBound-NTuple{4, Any}",href:"#Sindbad.DataLoaders.applyQCBound-NTuple{4, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.applyQCBound")],-1)),i[31]||(i[31]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[32]||(i[32]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">applyQCBound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_data, data_qc, bounds_qc, _data_fill)</span></span></code></pre></div><p>Apply quality control bounds to data values.</p><p><strong>Arguments</strong></p><ul><li><p><code>_data</code>: Input data array to be quality controlled</p></li><li><p><code>data_qc</code>: Quality control flags associated with the data</p></li><li><p><code>bounds_qc</code>: Bounds/thresholds for quality control checks</p></li><li><p><code>_data_fill</code>: Fill value to use for data points that fail QC</p></li></ul><p><strong>Returns</strong></p><p>The quality controlled data array with values outside bounds replaced by fill value</p>',6))]),e("details",A,[e("summary",null,[i[33]||(i[33]=e("a",{id:"Sindbad.DataLoaders.applyUnitConversion",href:"#Sindbad.DataLoaders.applyUnitConversion"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.applyUnitConversion")],-1)),i[34]||(i[34]=a()),n(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[35]||(i[35]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">applyUnitConversion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_data, conversion, isadditive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Applies a simple factor to the input, either additively or multiplicatively depending on isadditive flag</p><p><strong>Arguments</strong></p><ul><li><p><code>_data</code>: Input data to be converted</p></li><li><p><code>conversion</code>: Conversion factor or function to be applied</p></li><li><p><code>isadditive</code>: Boolean flag indicating whether the conversion is additive (default: false) or multiplicative</p></li></ul><p><strong>Returns</strong></p><p>Converted data with the applied unit transformation</p>',6))]),e("details",v,[e("summary",null,[i[36]||(i[36]=e("a",{id:"Sindbad.DataLoaders.cleanData-Union{Tuple{T}, Tuple{Any, Any, Any, Val{T}}} where T",href:"#Sindbad.DataLoaders.cleanData-Union{Tuple{T}, Tuple{Any, Any, Any, Val{T}}} where T"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.cleanData")],-1)),i[37]||(i[37]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[38]||(i[38]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cleanData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_data, _data_fill, _data_info, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T}</span></span></code></pre></div><p>Applies a series of cleaning steps to the data, including replacing invalid data, applying unit conversion, and clamping to bounds.</p><p><strong>Arguments</strong></p><ul><li><p><code>_data</code>: The raw data to be cleaned</p></li><li><p><code>_data_fill</code>: Fill values or parameters for handling missing/invalid data</p></li><li><p><code>_data_info</code>: Information about the data structure and cleaning requirements</p></li><li><p><code>::Val{T}</code>: Value type parameter for dispatch</p></li></ul><p><strong>Returns</strong></p><p>Cleaned data according to the specified type parameter T</p>',6))]),e("details",E,[e("summary",null,[i[39]||(i[39]=e("a",{id:"Sindbad.DataLoaders.collectForcingHelpers-Tuple{Any, Any, Any}",href:"#Sindbad.DataLoaders.collectForcingHelpers-Tuple{Any, Any, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.collectForcingHelpers")],-1)),i[40]||(i[40]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[41]||(i[41]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">collectForcingHelpers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(info, f_sizes, f_dimensions)</span></span></code></pre></div><p>Generates a NamedTuple of helper information for forcing data.</p><p><strong>Arguments:</strong></p><ul><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</p></li><li><p><code>f_sizes</code>: A NamedTuple containing the sizes of forcing dimensions.</p></li><li><p><code>f_dimensions</code>: A NamedTuple containing the dimensions of the forcing data.</p></li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple <code>f_helpers</code> containing helper information for forcing data.</li></ul><p><strong>Notes:</strong></p><ul><li>Includes dimensions, axes, subset information, and sizes for the forcing data.</li></ul>',8))]),e("details",D,[e("summary",null,[i[42]||(i[42]=e("a",{id:"Sindbad.DataLoaders.collectForcingSizes-Tuple{Any, Any}",href:"#Sindbad.DataLoaders.collectForcingSizes-Tuple{Any, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.collectForcingSizes")],-1)),i[43]||(i[43]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[44]||(i[44]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">collectForcingSizes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(info, in_yax)</span></span></code></pre></div><p>Collects the sizes of forcing dimensions from the input YAXArray.</p><p><strong>Arguments:</strong></p><ul><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</p></li><li><p><code>in_yax</code>: The input YAXArray containing forcing data.</p></li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple <code>f_sizes</code> where each dimension name is paired with its size.</li></ul><p><strong>Notes:</strong></p><ul><li><p>The function retrieves the size of the time dimension and spatial dimensions specified in the experiment configuration.</p></li><li><p>If the dimension is not directly accessible, it uses <code>DimensionalData.lookup</code> to retrieve the size.</p></li></ul>',8))]),e("details",C,[e("summary",null,[i[45]||(i[45]=e("a",{id:"Sindbad.DataLoaders.createForcingNamedTuple-NTuple{4, Any}",href:"#Sindbad.DataLoaders.createForcingNamedTuple-NTuple{4, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.createForcingNamedTuple")],-1)),i[46]||(i[46]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[47]||(i[47]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">createForcingNamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(incubes, f_sizes, f_dimensions, info)</span></span></code></pre></div><p>Creates a NamedTuple containing forcing data and metadata.</p><p><strong>Arguments:</strong></p><ul><li><p><code>incubes</code>: A collection of input cubes (YAXArray) containing forcing data.</p></li><li><p><code>f_sizes</code>: A NamedTuple containing the sizes of forcing dimensions.</p></li><li><p><code>f_dimensions</code>: A NamedTuple containing the dimensions of the forcing data.</p></li><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</p></li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple <code>forcing</code> containing: <ul><li><p><code>data</code>: The processed input cubes.</p></li><li><p><code>dims</code>: The dimensions of the forcing data.</p></li><li><p><code>variables</code>: The names of the forcing variables.</p></li><li><p><code>f_types</code>: The types of the forcing data (e.g., <code>ForcingWithTime</code> or <code>ForcingWithoutTime</code>).</p></li><li><p><code>helpers</code>: Helper information for the forcing data.</p></li></ul></li></ul><p><strong>Notes:</strong></p><ul><li><p>Processes the input cubes to determine their types and dimensions.</p></li><li><p>Helper information is generated using <code>collectForcingHelpers</code>.</p></li></ul>',8))]),e("details",S,[e("summary",null,[i[48]||(i[48]=e("a",{id:"Sindbad.DataLoaders.getAllConstraintData-NTuple{7, Any}",href:"#Sindbad.DataLoaders.getAllConstraintData-NTuple{7, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getAllConstraintData")],-1)),i[49]||(i[49]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[50]||(i[50]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getAllConstraintData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nc, data_backend, data_path, default_info, v_info, data_sub_field, info; yax</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, use_data_sub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Reads data from the observation file and returns the data, YAXArray, variable info, and bounds for the observation constraint.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nc</code>: The file or NetCDF object containing the observation data.</p></li><li><p><code>data_backend</code>: The backend used to process the data (e.g., NetCDF, Zarr).</p></li><li><p><code>data_path</code>: The path to the observation data file.</p></li><li><p><code>default_info</code>: Default variable information for constraints.</p></li><li><p><code>v_info</code>: Variable-specific information for the observation constraint, which can overwrite <code>default_info</code>.</p></li><li><p><code>data_sub_field</code>: The subfield of the observation data to process (e.g., <code>:data</code>, <code>:qflag</code>, <code>:unc</code>).</p></li><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</p></li><li><p><code>yax</code>: (Optional) The base observation YAXArray.</p></li><li><p><code>use_data_sub</code>: A flag indicating whether to use the subfield of the observation constraint.</p></li></ul><p><strong>Returns:</strong></p><ul><li><p><code>nc_sub</code>: The NetCDF object for the subfield.</p></li><li><p><code>yax_sub</code>: The YAXArray for the subfield.</p></li><li><p><code>v_info_sub</code>: The variable information for the subfield.</p></li><li><p><code>bounds_sub</code>: The bounds for the subfield.</p></li></ul><p><strong>Notes:</strong></p><ul><li><p>If the subfield is not provided or <code>use_data_sub</code> is <code>false</code>, default values are used.</p></li><li><p>Handles quality flags, uncertainty, spatial weights, and selection masks for observation constraints.</p></li></ul>',8))]),e("details",j,[e("summary",null,[i[51]||(i[51]=e("a",{id:"Sindbad.DataLoaders.getDataDims-Tuple{Any, Any}",href:"#Sindbad.DataLoaders.getDataDims-Tuple{Any, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getDataDims")],-1)),i[52]||(i[52]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[53]||(i[53]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getDataDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c, mappinginfo)</span></span></code></pre></div><p>Retrieves the dimensions of data based on provided mapping information.</p><p><strong>Arguments</strong></p><ul><li><p><code>c</code>: The container or data structure to get dimensions from</p></li><li><p><code>mappinginfo</code>: Information about how the data is mapped</p></li></ul><p><strong>Returns</strong></p><p>The dimensions of the data specified by the mapping information.</p>',6))]),e("details",F,[e("summary",null,[i[54]||(i[54]=e("a",{id:"Sindbad.DataLoaders.getDimPermutation-Tuple{Any, Any}",href:"#Sindbad.DataLoaders.getDimPermutation-Tuple{Any, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getDimPermutation")],-1)),i[55]||(i[55]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[56]||(i[56]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getDimPermutation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(datDims, permDims)</span></span></code></pre></div><p>Returns the permutation indices required to rearrange dimensions from <code>datDims</code> to match <code>permDims</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>datDims</code>: Array of current dimension names or indices</p></li><li><p><code>permDims</code>: Array of target dimension names or indices in desired order</p></li></ul><p><strong>Returns</strong></p><ul><li>Array of indices representing the required permutation</li></ul>',6))]),e("details",N,[e("summary",null,[i[57]||(i[57]=e("a",{id:"Sindbad.DataLoaders.getInputArrayOfType",href:"#Sindbad.DataLoaders.getInputArrayOfType"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getInputArrayOfType")],-1)),i[58]||(i[58]=a()),n(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[59]||(i[59]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getInputArrayOfType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input_data, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SindbadInputDataType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Converts the provided input data into a specific input array type.</p><p><strong>Arguments</strong></p><ul><li><p><code>input_data</code>: The data to be converted into an input array</p></li><li><p>&lt;: SindbadInputDataType: The specific input array type to convert the data into</p><ul><li><p><code>::InputArray</code>: Specifies the input array type as a simple array</p></li><li><p><code>::InputKeyedArray</code>: Specifies the input array type as a keyed array</p></li><li><p><code>::InputNamedDimsArray</code>: Specifies the input array type as a named dims array</p></li><li><p><code>::InputYaxArray</code>: Specifies the input array type as a YAX array</p></li></ul></li></ul><p><strong>Returns</strong></p><p>Returns the input data converted to the specified input array type.</p>',6))]),e("details",x,[e("summary",null,[i[60]||(i[60]=e("a",{id:"Sindbad.DataLoaders.getSindbadDims-Tuple{Any}",href:"#Sindbad.DataLoaders.getSindbadDims-Tuple{Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getSindbadDims")],-1)),i[61]||(i[61]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[62]||(i[62]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getSindbadDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c)</span></span></code></pre></div><p>prepare the dimensions of data and name them appropriately for use in internal SINDBAD functions</p><p><strong>Arguments</strong></p><ul><li><code>c</code>: input data cube</li></ul><p><strong>Returns</strong></p><p>Dimensions for use in SINDBAD</p>',6))]),e("details",I,[e("summary",null,[i[63]||(i[63]=e("a",{id:"Sindbad.DataLoaders.getTargetDimensionOrder-Tuple{Any}",href:"#Sindbad.DataLoaders.getTargetDimensionOrder-Tuple{Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getTargetDimensionOrder")],-1)),i[64]||(i[64]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[65]||(i[65]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getTargetDimensionOrder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(info)</span></span></code></pre></div><p>Retrieves the target dimension order to organize the forcing data from the provided information.</p><p><strong>Arguments</strong></p><ul><li><code>info</code>: Input information containing dimension order details.</li></ul><p><strong>Returns</strong></p><p>The ordered sequence of dimensions for the target.</p>',6))]),e("details",B,[e("summary",null,[i[66]||(i[66]=e("a",{id:"Sindbad.DataLoaders.getYaxFromSource",href:"#Sindbad.DataLoaders.getYaxFromSource"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.getYaxFromSource")],-1)),i[67]||(i[67]=a()),n(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[68]||(i[68]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getYaxFromSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nc, data_path, data_path_v, source_variable, info, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DataFormatBackend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Retrieve the data from a specified source.</p><p><strong>Arguments</strong></p><ul><li><p><code>nc</code>: The NetCDF file or object to read data from.</p></li><li><p><code>data_path</code>: The path to the data within the NetCDF file.</p></li><li><p><code>data_path_v</code>: The path to the variable within the NetCDF file.</p></li><li><p><code>source_variable</code>: The name of the source variable to extract data for.</p></li><li><p><code>info</code>: Additional information or metadata required for processing.</p></li><li><p><code>&lt;: DataFormatBackend</code>: Specifies the SINDBAD backend being used.</p><ul><li><p><code>::BackendNetcdf</code>: Specifies that the function operates on a NetCDF backend.</p></li><li><p><code>::BackendZarr</code>: Specifies that the backend being used is Zarr.</p></li></ul></li></ul><p><strong>Returns</strong></p><ul><li>The file object and extracted YAX data from the specified source.</li></ul><p><strong>Notes</strong></p><ul><li><p>Ensure that the <code>nc</code> object and paths provided are valid and accessible.</p></li><li><p>The functions are specific to the NetCDF and Zarr backend and may not work with other backends.</p></li></ul>',8))]),e("details",L,[e("summary",null,[i[69]||(i[69]=e("a",{id:"Sindbad.DataLoaders.loadDataFile-Tuple{Any}",href:"#Sindbad.DataLoaders.loadDataFile-Tuple{Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.loadDataFile")],-1)),i[70]||(i[70]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[71]||(i[71]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loadDataFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data_path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Any</span></span></code></pre></div><p>Load data from the specified file path.</p><p><strong>Arguments</strong></p><ul><li><code>data_path::String</code>: The path to the data file to be loaded.</li></ul><p><strong>Returns</strong></p><ul><li>The data loaded from the specified file. The return type depends on the file format and its contents.</li></ul><p><strong>Notes</strong></p><ul><li><p>Ensure that the file exists and is accessible at the given path.</p></li><li><p>The function assumes the file format is supported by the implementation.</p></li></ul>',8))]),e("details",P,[e("summary",null,[i[72]||(i[72]=e("a",{id:"Sindbad.DataLoaders.loadDataFromPath-NTuple{4, Any}",href:"#Sindbad.DataLoaders.loadDataFromPath-NTuple{4, Any}"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.loadDataFromPath")],-1)),i[73]||(i[73]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[74]||(i[74]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loadDataFromPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nc, data_path, data_path_v, source_variable)</span></span></code></pre></div><p>Load data from specified NetCDF paths using given parameters.</p><p><strong>Arguments</strong></p><ul><li><p><code>nc</code>: NetCDF file handle</p></li><li><p><code>data_path</code>: Path to the main data in NetCDF file</p></li><li><p><code>data_path_v</code>: Path to the variable data in NetCDF file</p></li><li><p><code>source_variable</code>: Name of the source variable to load</p></li></ul><p><strong>Returns</strong></p><p>Data loaded from the specified paths in the NetCDF file.</p>',6))]),e("details",V,[e("summary",null,[i[75]||(i[75]=e("a",{id:"Sindbad.DataLoaders.spatialSubset",href:"#Sindbad.DataLoaders.spatialSubset"},[e("span",{class:"jlbinding"},"Sindbad.DataLoaders.spatialSubset")],-1)),i[76]||(i[76]=a()),n(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[77]||(i[77]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">spatialSubset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v, ss_range, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SpatialSubsetter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Extracts a spatial subset of the input data <code>v</code> based on the specified range and spatial dimension.</p><p><strong>Arguments:</strong></p><ul><li><p><code>v</code>: The input data from which a spatial subset is to be extracted.</p></li><li><p><code>ss_range</code>: The range of indices or values to subset along the specified spatial dimension.</p></li></ul><p><strong>Returns:</strong></p><ul><li>A subset of the input data <code>v</code> corresponding to the specified spatial range and dimension.</li></ul><p><strong>SpatialSubsetter</strong></p><p>Abstract type for spatial subsetting methods in SINDBAD</p><p><strong>Available methods/subtypes:</strong></p><ul><li><p><code>SpaceID</code>: Use site ID (all caps) for spatial subsetting</p></li><li><p><code>SpaceId</code>: Use site ID (capitalized) for spatial subsetting</p></li><li><p><code>Spaceid</code>: Use site ID for spatial subsetting</p></li><li><p><code>Spacelat</code>: Use latitude for spatial subsetting</p></li><li><p><code>Spacelatitude</code>: Use full latitude for spatial subsetting</p></li><li><p><code>Spacelon</code>: Use longitude for spatial subsetting</p></li><li><p><code>Spacelongitude</code>: Use full longitude for spatial subsetting</p></li><li><p><code>Spacesite</code>: Use site location for spatial subsetting</p></li></ul><hr><p><strong>Extended help</strong></p><p><strong>Notes:</strong></p><ul><li><p>The function dynamically selects the appropriate field in <code>v</code> based on the spatial type provided.</p></li><li><p>The spatial type determines the field name (e.g., <code>site</code>, <code>lat</code>, <code>longitude</code>, <code>id</code>, etc.) used for subsetting.</p></li></ul><p><strong>Examples:</strong></p><ol><li><strong>Subsetting by latitude</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> spatialSubset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Spacelat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><ol><li><strong>Subsetting by longitude</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> spatialSubset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Spacelongitude</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><ol><li><strong>Subsetting by site ID</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> spatialSubset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Spaceid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div>',21))])])}const X=l(r,[["render",R]]);export{z as __pageData,X as default};
